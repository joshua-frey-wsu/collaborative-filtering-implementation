## **User-User Collaborative Filtering**

# This cell provides some useful functions for generating the utility matrix.
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import LabelEncoder
from scipy.sparse import csr_matrix
import os
import pandas as pd
import numpy as np
import zipfile
import urllib.request
import sys

def unzip(name):
    with zipfile.ZipFile(name, 'r') as data:
        data.extractall()

class ml100k:
    @staticmethod
    def load():
        name = 'ml-100k'
        unzip(f"{name}.zip")
        ratings_path = os.path.join(name, 'u.data')
        ratings = pd.read_csv(
            ratings_path,
            sep='\t',
            names=["userid", "itemid", "rating", "timestamp"],
        )
        ratings = ratings.sort_values(by=['userid', 'itemid']).reset_index(drop=True)
        ratings = ratings.drop(columns=['timestamp'])

        movies_columns = [
            'itemid', 'title', 'release date', 'video release date',
            'IMDb URL ', 'unknown', 'Action', 'Adventure', 'Animation',
            "Children's", 'Comedy' , 'Crime' , 'Documentary' , 'Drama' , 'Fantasy' ,
            'Film-Noir', 'Horror', 'Musical' , 'Mystery' , 'Romance' , 'Sci-Fi' ,
            'Thriller' , 'War' , 'Western' ,
        ]

        movies_path = os.path.join(name, 'u.item')
        movies = pd.read_csv(
            movies_path,
            sep='|',
            names=movies_columns,
            encoding='latin-1',
        )
        # drop non necessary columns. From the third to the last column
        todrop = list(range(2, len(movies.columns)))
        movies = movies.drop(movies.columns[todrop], axis=1)

        return ratings, movies

def ids_encoder(ratings):
    users = sorted(ratings['userid'].unique())
    items = sorted(ratings['itemid'].unique())

    # create users and items encoders
    uencoder = LabelEncoder()
    iencoder = LabelEncoder()

    # fit users and items ids to the corresponding encoder
    uencoder.fit(users)
    iencoder.fit(items)

    # encode userids and itemids
    ratings.userid = uencoder.transform(ratings.userid.tolist())
    ratings.itemid = iencoder.transform(ratings.itemid.tolist())
    return ratings, uencoder, iencoder

def ratings_matrix(ratings):
    # return a rating matrix based with filling values
    return csr_matrix(pd.crosstab(ratings.userid, ratings.itemid, ratings.rating, aggfunc=sum).fillna(0).values)

# Generate utility information
def generate_utility_matrix():
    ratings, movies = ml100k.load()
    ratings, uencoder, iencoder = ids_encoder(ratings)
    return ratings

def create_model(rating_matrix, metric):
    """
    - create the nearest neighbors model with the corresponding similarity metric
    - fit the model
    """
    model = NearestNeighbors(metric=metric, n_neighbors=21, algorithm='brute')
    model.fit(rating_matrix)
    return model


def nearest_neighbors(rating_matrix):
    """
    :param rating_matrix : rating matrix of shape (nb_users, nb_items)
    :return
        - similarities : distances of the neighbors from the referenced user
        - neighbors : neighbors of the referenced user in decreasing order of similarities
    """
    rating_matrix = np.array(rating_matrix)
    if rating_matrix.shape != (943, 1682):
         raise ValueError("Rating Matrix is not of the right shape")

    model = create_model(rating_matrix, metric='cosine')
    similarities, neighbors = model.kneighbors(rating_matrix)
    return 1 - similarities[:, 1:], neighbors[:, 1:]


def find_candidate_items(userid):
    """
    Find candidate items for an active user

    :param userid : active user
    :param neighbors : users similar to the active user
    :return candidates : top 30 of candidate items
    """
    ratings_ = generate_utility_matrix()
    R_ = ratings_matrix(ratings_)
    ar = R_.toarray()
    similarities_, neighbors_ = nearest_neighbors(ar)
    user_neighbors = neighbors_[userid]
    activities = ratings_.loc[ratings_.userid.isin(user_neighbors)]
    # sort items in decreasing order of frequency
    frequency = activities.groupby('itemid')['rating'].count().reset_index(name='count').sort_values(['count'],ascending=False)
    Gu_items = frequency.itemid
    active_items = ratings_.loc[ratings_.userid == userid].itemid.to_list()
    candidates = np.setdiff1d(Gu_items, active_items, assume_unique=True)[:30]

    return candidates

"""# 1. User-based Collaborative Filtering
"""
def generate_centered_rating_matrix(ratings):
    """
    Please fill up your implementation.
    The input of the function is the original rating matrix "ratings" generated by the function "generate_utility_matrix()".
    The ratings is a pandas dataframe.

    Since we have 943 users and 1682 movies in the sytem.

    The output matrix should be a numpy array with shape 943 * 1682.
    The (i,j) element for the matrix is the centered rating from user i (with userid i) of move j (with itemid j).
    All the missing ratings are filling up with value 0.
    For the centered rating matrix, for example if the original rating matrix is:
    [[ 4 0 0 5 1 0],
     [ 5 5 4 0 0 0],
     [ 0 0 3 0 0 1]]
    Then the centered rating matrix is:
    [[ 2/3 0 0 5/3 -7/3 0],
     [ 1/3 1/3 -2/3 0 0 0],
     [ 0 0 1 0 0 -1]]
     Refer to Slide 8 - 1.

     Note that: All the missing values remain to be 0. The mean of each row is calculated among all the positive ratings (active ratings).
    """
    #print(ratings)
    # first use pivot_table function to change the dataframe so that we can make the row index be by the userid and the values be the ratings for each itemid
    ratings_pivot_table = pd.pivot_table(ratings, index='userid', columns='itemid', values='rating', fill_value=0)
    #print(ratings_pivot_table)
    # then we can convert it to a numpy array
    original_rating_matrix = ratings_pivot_table.to_numpy()
    #print(original_rating_matrix)
    original_rating_matrix = np.where(original_rating_matrix==0, np.nan, original_rating_matrix) # change all the values that are 0 to nan
    # traverse original_rating_matrix
    for row in original_rating_matrix:
      mean = np.nanmean(row) # compute the nanmean of each row
      # go through each rating in the row
      for i in range(len(row)):
        # if the rating is a nan use a 0 to subtracst from mean
        if np.isnan(row[i]):
          row[i] = 0 - mean
        else:
          row[i] = row[i] - mean
    center_rating_matrix = original_rating_matrix
    #print(center_rating_matrix)
    # now take the mean of each row without including zeros and subtract it to each value in the row
    
    return center_rating_matrix

"""### Step 3. Rating prediction
"""
def predict(ratings, userid, itemid, similarities, neighbors):
    """
    predict what score userid would have given to itemid.

    :param
        - userid : user id for which we want to make prediction
        - itemid : item id on which we want to make prediction
        - similarities: a matrix contains the consin distance between user and its nearest 20 neighbors
        - neighbors: a matrix contains the most 20 closed users for each user

    :return
        - r_hat : predicted rating of user userid on item itemid
    """

    #Obtain neighbors N_u and associated similarity distance s_{u,v}
    user_similarities = similarities[userid] #list with size 20
    user_neighbors = neighbors[userid] #list with size 20

    #Something you need to do here
    # 1. Get mean rating of user userid
    #print(ratings)
    # first use pivot_table function to change the dataframe so that we can make the row index be by the userid and the values be the ratings for each itemid
    ratings_pivot_table = pd.pivot_table(ratings, index='userid', columns='itemid', values='rating', fill_value=0)
    #print(ratings_pivot_table)
    # then we can convert it to a numpy array
    original_rating_matrix = ratings_pivot_table.to_numpy()
    #print(original_rating_matrix)
    original_rating_matrix = np.where(original_rating_matrix==0, np.nan, original_rating_matrix) # change all the values that are 0 to nan
    # traverse original_rating_matrix
    mean_user_u = np.nanmean(original_rating_matrix[userid]) # gets the mean rating of user userid

    # 2. Find users who rated item 'itemid'
    list_user_means = []
    users_rating_itemid = {}
    userIndex = 0
    for row in original_rating_matrix:
      list_user_means.append(np.nanmean(row)) # gets the mean of each user in a list
      # if the user rated this item then add a key-value pair of the userid and rating to the dictionary of users_rating_itemid since the rating is not NAN
      if np.isnan(row[itemid]) == False:
        users_rating_itemid[userIndex] = row[itemid]
      userIndex += 1 # increment to next user

    # 3. Find similar users to 'userid' who rated item 'itemid' (userids contained among the users found by last step)
    similar_user_rating_itemid = {}
    user_neighbors_index = 0
    # Goes through each similar user is user_neighbors
    for similar_user in user_neighbors:
      # if the userid of a similar user matches one of the users who rated item i then store the index of where it is in the user_neighbors so we can correlate it with user_similarites list
      if similar_user in users_rating_itemid.keys():
        similar_user_rating_itemid[similar_user] = user_neighbors_index
      user_neighbors_index += 1

    # 4. Obtain similarity distance from user_similarities
    numerator = 0
    denominator = 0
    for v in similar_user_rating_itemid.keys():
      normalized_value = (users_rating_itemid[v] - list_user_means[v])
      sim = user_similarities[similar_user_rating_itemid[v]]
      numerator += normalized_value * sim
      denominator += abs(sim)

    fraction = 0
    # check divide by zero case
    if denominator != 0:
      fraction = numerator / denominator

    r_hat = mean_user_u + fraction

    return r_hat


"""### Step 4. Top-N recommendation

Function ```user2userRecommendation(userid, N)``` return the list of Top-N (N<= 20) items in decreasing order of predicted rating for user userid.

**Your Answer is needed in the following cell:**
"""

def user2userRecommendation(ratings, userid: int, N : int):
    """
    Recommend movies to user (id = userid)
    :param
        - userid : user id for which we want to make prediction
    :return
        - r_list : list of recommended itemids
    """
    # find candidate items for the active user
    # You need to recommend movies from the set of candidates
    # candidates is a list of all the ponential items that can be recommended to user (id=userid)
    candidates = find_candidate_items(userid)

    centered_rating = generate_centered_rating_matrix(ratings)
    centered_rating = np.array(centered_rating)
    similarities, neighbors = nearest_neighbors(centered_rating)
    r_dictionary = {}
    for potential_item in candidates:
      r_hat = predict(ratings, userid, potential_item, similarities, neighbors)
      r_dictionary[potential_item] = r_hat
    sorted_list = sorted(r_dictionary.items(), key=lambda x:x[1], reverse=True)
    r_list = []
    for i in range(N):
      r_list.append(sorted_list[i][0])

    return r_list
  